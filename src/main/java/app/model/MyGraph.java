package app.model;

import static lombok.AccessLevel.PROTECTED;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import app.utility.VertexUtility;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

/**
 * 09/06/2022.
 *
 * @author Laurent Lamiral
 */

@Data
public class MyGraph {

	@Getter(PROTECTED)
	@Setter(PROTECTED)
	private Set<Vertex> vertices = new HashSet<>();

	@Getter(PROTECTED)
	@Setter(PROTECTED)
	private Long autoGeneratedIdVertices = 1L;

	public void addVertex() {

		vertices.add(new Vertex(autoGeneratedIdVertices));
		autoGeneratedIdVertices++; // May not be thread safe.

	}

	public void addVertex(final int amount) {
		for (int i = 1; i <= amount; i++) {
			addVertex();
		}

	}

	public void addEdge(final Long originVertexId, final Long endVertexId, final int weight, final boolean isDirected) {

		final Vertex origin = getVertexById(originVertexId).orElseThrow();
		final Vertex end = getVertexById(endVertexId).orElseThrow();

		if (weight < 0) {
			throw new IllegalArgumentException();

		}

		origin.addEdge(end, weight);

		if (!isDirected) {

			end.addEdge(origin, weight);
		}

	}

	public void removeEdge(final Long originVertexId, final Edge edge) {

		final Vertex origin = getVertexById(originVertexId).orElseThrow();
		origin.removeEdge(edge);

	}

	public void addEdge(final Long originVertexId, final Long endVertexId, final int weight) {

		addEdge(originVertexId, endVertexId, weight, false);

	}

	public Optional<Vertex> getVertexById(final Long id) {

		return VertexUtility.getVertexById(id, vertices);

	}

	public Set<Vertex> getVerticesView() {

		return vertices	.stream()
						.map(Vertex::copy)
						.collect(Collectors.toSet());

	}

	public Set<DijktraVertex> mapToDijktraVertices() {

		return vertices	.stream()
						.map(v -> new DijktraVertex(v.copy()))
						.collect(Collectors.toSet());

	}

}
